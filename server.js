const express = require('express');
const { createCanvas, registerFont } = require('canvas');
const cors = require('cors');
const helmet = require('helmet');
const Stripe = require('stripe');
const { RateLimiterMemory } = require('rate-limiter-flexible');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Stripe initialization
const stripe = process.env.STRIPE_SECRET_KEY ? new Stripe(process.env.STRIPE_SECRET_KEY) : null;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Rate limiter - 100 requests per hour for free tier
const rateLimiter = new RateLimiterMemory({
  points: 100,
  duration: 3600,
});

// Simple API key validation (replace with database in production)
const API_KEYS = new Map([
  ['demo_key_12345', { tier: 'free', limit: 100 }],
  ['premium_key_67890', { tier: 'premium', limit: 10000 }],
]);

// Middleware to check API key
const checkApiKey = async (req, res, next) => {
  const apiKey = req.headers['x-api-key'];
  
  if (!apiKey) {
    return res.status(401).json({ error: 'API key required' });
  }
  
  const keyData = API_KEYS.get(apiKey);
  if (!keyData) {
    return res.status(403).json({ error: 'Invalid API key' });
  }
  
  // Rate limiting
  try {
    await rateLimiter.consume(apiKey);
    req.apiKeyData = keyData;
    next();
  } catch (rejRes) {
    res.status(429).json({ 
      error: 'Rate limit exceeded',
      retryAfter: Math.round(rejRes.msBeforeNext / 1000) 
    });
  }
};

// Function to generate OG image
function generateOGImage(options) {
  const {
    title = 'Default Title',
    subtitle = '',
    theme = 'gradient',
    width = 1200,
    height = 630,
  } = options;

  const canvas = createCanvas(width, height);
  const ctx = canvas.getContext('2d');

  // Background based on theme
  if (theme === 'gradient') {
    const gradient = ctx.createLinearGradient(0, 0, width, height);
    gradient.addColorStop(0, '#667eea');
    gradient.addColorStop(1, '#764ba2');
    ctx.fillStyle = gradient;
  } else if (theme === 'dark') {
    ctx.fillStyle = '#1a202c';
  } else if (theme === 'light') {
    ctx.fillStyle = '#ffffff';
  } else if (theme === 'tech') {
    const gradient = ctx.createLinearGradient(0, 0, width, height);
    gradient.addColorStop(0, '#0f2027');
    gradient.addColorStop(0.5, '#203a43');
    gradient.addColorStop(1, '#2c5364');
    ctx.fillStyle = gradient;
  }
  
  ctx.fillRect(0, 0, width, height);

  // Add decorative elements
  ctx.globalAlpha = 0.1;
  for (let i = 0; i < 20; i++) {
    ctx.beginPath();
    ctx.arc(
      Math.random() * width,
      Math.random() * height,
      Math.random() * 100 + 50,
      0,
      Math.PI * 2
    );
    ctx.fillStyle = theme === 'light' ? '#000000' : '#ffffff';
    ctx.fill();
  }
  ctx.globalAlpha = 1.0;

  // Text styling
  const textColor = theme === 'light' ? '#1a202c' : '#ffffff';
  ctx.fillStyle = textColor;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // Title
  ctx.font = 'bold 72px Arial, sans-serif';
  const maxTitleWidth = width - 200;
  let titleFontSize = 72;
  
  // Auto-resize title to fit
  while (ctx.measureText(title).width > maxTitleWidth && titleFontSize > 30) {
    titleFontSize -= 2;
    ctx.font = `bold ${titleFontSize}px Arial, sans-serif`;
  }
  
  // Word wrap for title
  const words = title.split(' ');
  let line = '';
  let lines = [];
  
  for (let word of words) {
    const testLine = line + word + ' ';
    if (ctx.measureText(testLine).width > maxTitleWidth) {
      lines.push(line);
      line = word + ' ';
    } else {
      line = testLine;
    }
  }
  lines.push(line);
  
  const lineHeight = titleFontSize * 1.2;
  const startY = height / 2 - ((lines.length - 1) * lineHeight) / 2;
  
  lines.forEach((line, i) => {
    ctx.fillText(line.trim(), width / 2, startY + i * lineHeight);
  });

  // Subtitle
  if (subtitle) {
    ctx.font = '32px Arial, sans-serif';
    ctx.fillStyle = textColor;
    ctx.globalAlpha = 0.8;
    ctx.fillText(subtitle, width / 2, height - 100);
    ctx.globalAlpha = 1.0;
  }

  // Branding
  ctx.font = '24px Arial, sans-serif';
  ctx.fillStyle = textColor;
  ctx.globalAlpha = 0.5;
  ctx.fillText('Generated by OG Image API', width / 2, height - 40);
  ctx.globalAlpha = 1.0;

  return canvas.toBuffer('image/png');
}

// API Routes

// Health check
app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', version: '1.0.0' });
});

// Generate OG image - main endpoint
app.post('/api/generate', checkApiKey, (req, res) => {
  try {
    const { title, subtitle, theme, width, height } = req.body;
    
    if (!title) {
      return res.status(400).json({ error: 'Title is required' });
    }

    const imageBuffer = generateOGImage({
      title,
      subtitle,
      theme,
      width: parseInt(width) || 1200,
      height: parseInt(height) || 630,
    });

    res.setHeader('Content-Type', 'image/png');
    res.setHeader('Cache-Control', 'public, max-age=31536000');
    res.send(imageBuffer);
  } catch (error) {
    console.error('Error generating image:', error);
    res.status(500).json({ error: 'Failed to generate image' });
  }
});

// GET endpoint for easy testing
app.get('/api/generate', checkApiKey, (req, res) => {
  try {
    const { title, subtitle, theme, width, height } = req.query;
    
    if (!title) {
      return res.status(400).json({ error: 'Title is required' });
    }

    const imageBuffer = generateOGImage({
      title,
      subtitle,
      theme,
      width: parseInt(width) || 1200,
      height: parseInt(height) || 630,
    });

    res.setHeader('Content-Type', 'image/png');
    res.setHeader('Cache-Control', 'public, max-age=31536000');
    res.send(imageBuffer);
  } catch (error) {
    console.error('Error generating image:', error);
    res.status(500).json({ error: 'Failed to generate image' });
  }
});

// Stripe webhook for subscription management
app.post('/api/webhook', express.raw({ type: 'application/json' }), async (req, res) => {
  if (!stripe) {
    return res.status(503).json({ error: 'Stripe not configured' });
  }

  const sig = req.headers['stripe-signature'];
  let event;

  try {
    event = stripe.webhooks.constructEvent(
      req.body,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET
    );
  } catch (err) {
    console.error('Webhook signature verification failed:', err.message);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // Handle subscription events
  switch (event.type) {
    case 'checkout.session.completed':
      const session = event.data.object;
      console.log('Subscription created:', session.id);
      // TODO: Create API key and send to customer
      break;
    
    case 'customer.subscription.deleted':
      const subscription = event.data.object;
      console.log('Subscription cancelled:', subscription.id);
      // TODO: Revoke API key
      break;
  }

  res.json({ received: true });
});

// Create checkout session
app.post('/api/create-checkout', async (req, res) => {
  if (!stripe) {
    return res.status(503).json({ error: 'Stripe not configured' });
  }

  try {
    const { priceId, email } = req.body;
    
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: [{
        price: priceId,
        quantity: 1,
      }],
      mode: 'subscription',
      success_url: `${process.env.DOMAIN || 'http://localhost:3000'}/success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.DOMAIN || 'http://localhost:3000'}/pricing`,
      customer_email: email,
    });

    res.json({ sessionId: session.id });
  } catch (error) {
    console.error('Error creating checkout session:', error);
    res.status(500).json({ error: 'Failed to create checkout session' });
  }
});

app.listen(PORT, () => {
  console.log(`üöÄ OG Image SaaS API running on port ${PORT}`);
  console.log(`üìù API Docs: http://localhost:${PORT}`);
  console.log(`üîë Demo API Key: demo_key_12345`);
});
